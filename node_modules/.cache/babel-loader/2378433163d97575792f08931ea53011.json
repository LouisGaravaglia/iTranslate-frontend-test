{"ast":null,"code":"import { GET_TRANSLATION, UPDATE_TRANSLATION_ERRORS } from \"../actionTypes\";\nimport IBMWatsonAPI from \"../IBMWatsonAPI\";\nimport BackendCall from '../BackendCall';\n/**\n* Receives the lyrics and desired target language and checks the databse\n* to see if we have that specific translation. If not, it will make a call\n* to the IBM API to get translation. \n* @param {string} targetLanguage - language input value user entered\n* @param {array} languages - available languages IBM can translate to\n* @param {string} trackId - spotify id of song selected\n* @param {string} lyrics - lyrics from song selected\n*/\n\nexport function getTranslation(targetLanguage, languages, trackId, lyrics) {\n  return async function (dispatch) {\n    const errors = {\n      languageError: false,\n      translationError: false\n    };\n\n    const fetchTranslation = async (language, trackId, lyrics) => {\n      try {\n        //CHECKING TO SEE IF WE HAVE THAT SONG WITH THAT TRACK ID AND THE SPECIFIED LANGUAGE IN OUR TRANSLATION TABLE\n        const response = await BackendCall.getTranslationFromDB({\n          track_id: trackId,\n          selectedLanguage: language\n        });\n\n        if (response === \"No Translation in DB\") {\n          const IBMTranslation = await IBMWatsonAPI.getTranslationFromAPI(lyrics, language);\n\n          if (IBMTranslation === \"Error attempting to read source text\") {\n            errors[\"translationError\"] = true;\n            return \"No Translation Available\";\n          } else {\n            await BackendCall.addTranslation({\n              track_id: trackId,\n              language,\n              translation: IBMTranslation\n            });\n            return IBMTranslation;\n          }\n\n          ;\n        } else {\n          return response;\n        }\n\n        ;\n      } catch (e) {\n        errors[\"translationError\"] = true;\n        return \"No Translation Available\";\n      }\n\n      ;\n    };\n\n    const handleLanguageSearchSubmit = async (targetLanguage, languages) => {\n      let language;\n\n      try {\n        //FILTER OVER LANGUAGES IBM CAN TRANSLATE TO AND PULL OUT THE LANGUAGE-CODE OF THE LANGUAGE THE USER WANT'S TO USE\n        [{\n          language\n        }] = languages.filter(l => l.language_name.toLowerCase() === targetLanguage.toLowerCase());\n      } catch (e) {\n        errors[\"languageError\"] = true;\n        return \"Could not read language value\";\n      }\n\n      ;\n      const translation = await fetchTranslation(language, trackId, lyrics);\n      return translation;\n    };\n\n    const translation = await handleLanguageSearchSubmit(targetLanguage, languages);\n    dispatch(retrieveTranslation(translation));\n    dispatch(updateGetTranslationErrors(errors));\n  };\n}\n;\n\nfunction retrieveTranslation(translation) {\n  return {\n    type: GET_TRANSLATION,\n    translation\n  };\n}\n\n;\n\nfunction updateGetTranslationErrors(errors) {\n  return {\n    type: UPDATE_TRANSLATION_ERRORS,\n    errors\n  };\n}\n\n;","map":{"version":3,"sources":["/Users/louieg3/Documents/Web_development/iTranslate/Frontend/src/actionCreators/getTranslationCreator.js"],"names":["GET_TRANSLATION","UPDATE_TRANSLATION_ERRORS","IBMWatsonAPI","BackendCall","getTranslation","targetLanguage","languages","trackId","lyrics","dispatch","errors","languageError","translationError","fetchTranslation","language","response","getTranslationFromDB","track_id","selectedLanguage","IBMTranslation","getTranslationFromAPI","addTranslation","translation","e","handleLanguageSearchSubmit","filter","l","language_name","toLowerCase","retrieveTranslation","updateGetTranslationErrors","type"],"mappings":"AAAA,SAAQA,eAAR,EAAyBC,yBAAzB,QAAyD,gBAAzD;AACA,OAAOC,YAAP,MAAyB,iBAAzB;AACA,OAAOC,WAAP,MAAwB,gBAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,cAAT,CAAwBC,cAAxB,EAAwCC,SAAxC,EAAmDC,OAAnD,EAA4DC,MAA5D,EAAoE;AAEzE,SAAO,gBAAeC,QAAf,EAAyB;AAC9B,UAAMC,MAAM,GAAG;AAACC,MAAAA,aAAa,EAAE,KAAhB;AAAuBC,MAAAA,gBAAgB,EAAE;AAAzC,KAAf;;AAEA,UAAMC,gBAAgB,GAAG,OAAOC,QAAP,EAAiBP,OAAjB,EAA0BC,MAA1B,KAAqC;AAC5D,UAAI;AAEF;AACA,cAAMO,QAAQ,GAAG,MAAMZ,WAAW,CAACa,oBAAZ,CAAiC;AAACC,UAAAA,QAAQ,EAAEV,OAAX;AAAoBW,UAAAA,gBAAgB,EAAEJ;AAAtC,SAAjC,CAAvB;;AAEA,YAAIC,QAAQ,KAAK,sBAAjB,EAAyC;AACvC,gBAAMI,cAAc,GAAG,MAAMjB,YAAY,CAACkB,qBAAb,CAAmCZ,MAAnC,EAA2CM,QAA3C,CAA7B;;AAEA,cAAIK,cAAc,KAAK,sCAAvB,EAA+D;AAC7DT,YAAAA,MAAM,CAAC,kBAAD,CAAN,GAA6B,IAA7B;AACA,mBAAO,0BAAP;AACD,WAHD,MAGO;AACL,kBAAMP,WAAW,CAACkB,cAAZ,CAA2B;AAACJ,cAAAA,QAAQ,EAAEV,OAAX;AAAoBO,cAAAA,QAApB;AAA8BQ,cAAAA,WAAW,EAAEH;AAA3C,aAA3B,CAAN;AACA,mBAAOA,cAAP;AACD;;AAAA;AACF,SAVD,MAUO;AACL,iBAAOJ,QAAP;AACD;;AAAA;AAEF,OAnBD,CAmBE,OAAMQ,CAAN,EAAS;AACTb,QAAAA,MAAM,CAAC,kBAAD,CAAN,GAA6B,IAA7B;AACA,eAAO,0BAAP;AACD;;AAAA;AACF,KAxBD;;AA0BA,UAAMc,0BAA0B,GAAG,OAAOnB,cAAP,EAAuBC,SAAvB,KAAqC;AACtE,UAAIQ,QAAJ;;AACA,UAAG;AACD;AACA,SAAC;AAACA,UAAAA;AAAD,SAAD,IAAeR,SAAS,CAACmB,MAAV,CAAiBC,CAAC,IAAIA,CAAC,CAACC,aAAF,CAAgBC,WAAhB,OAAkCvB,cAAc,CAACuB,WAAf,EAAxD,CAAf;AACD,OAHD,CAGE,OAAML,CAAN,EAAS;AACTb,QAAAA,MAAM,CAAC,eAAD,CAAN,GAA0B,IAA1B;AACA,eAAO,+BAAP;AACD;;AAAA;AAED,YAAMY,WAAW,GAAG,MAAMT,gBAAgB,CAACC,QAAD,EAAWP,OAAX,EAAoBC,MAApB,CAA1C;AACA,aAAOc,WAAP;AACD,KAZD;;AAcA,UAAMA,WAAW,GAAG,MAAME,0BAA0B,CAACnB,cAAD,EAAiBC,SAAjB,CAApD;AACAG,IAAAA,QAAQ,CAACoB,mBAAmB,CAACP,WAAD,CAApB,CAAR;AACAb,IAAAA,QAAQ,CAACqB,0BAA0B,CAACpB,MAAD,CAA3B,CAAR;AACD,GA9CD;AA+CD;AAAA;;AAED,SAASmB,mBAAT,CAA6BP,WAA7B,EAA0C;AACxC,SAAO;AAACS,IAAAA,IAAI,EAAE/B,eAAP;AAAwBsB,IAAAA;AAAxB,GAAP;AACD;;AAAA;;AAED,SAASQ,0BAAT,CAAoCpB,MAApC,EAA4C;AAC1C,SAAO;AAACqB,IAAAA,IAAI,EAAE9B,yBAAP;AAAkCS,IAAAA;AAAlC,GAAP;AACD;;AAAA","sourcesContent":["import {GET_TRANSLATION, UPDATE_TRANSLATION_ERRORS} from \"../actionTypes\";\nimport IBMWatsonAPI from \"../IBMWatsonAPI\";\nimport BackendCall from '../BackendCall';\n\n/**\n* Receives the lyrics and desired target language and checks the databse\n* to see if we have that specific translation. If not, it will make a call\n* to the IBM API to get translation. \n* @param {string} targetLanguage - language input value user entered\n* @param {array} languages - available languages IBM can translate to\n* @param {string} trackId - spotify id of song selected\n* @param {string} lyrics - lyrics from song selected\n*/\nexport function getTranslation(targetLanguage, languages, trackId, lyrics) {\n\n  return async function(dispatch) {\n    const errors = {languageError: false, translationError: false};\n\n    const fetchTranslation = async (language, trackId, lyrics) => {\n      try {\n\n        //CHECKING TO SEE IF WE HAVE THAT SONG WITH THAT TRACK ID AND THE SPECIFIED LANGUAGE IN OUR TRANSLATION TABLE\n        const response = await BackendCall.getTranslationFromDB({track_id: trackId, selectedLanguage: language});\n\n        if (response === \"No Translation in DB\") {\n          const IBMTranslation = await IBMWatsonAPI.getTranslationFromAPI(lyrics, language);\n\n          if (IBMTranslation === \"Error attempting to read source text\") {\n            errors[\"translationError\"] = true;\n            return \"No Translation Available\";\n          } else {\n            await BackendCall.addTranslation({track_id: trackId, language, translation: IBMTranslation});\n            return IBMTranslation;\n          };\n        } else {\n          return response;\n        };\n\n      } catch(e) {\n        errors[\"translationError\"] = true;\n        return \"No Translation Available\";\n      };\n    };\n\n    const handleLanguageSearchSubmit = async (targetLanguage, languages) => {\n      let language;\n      try{\n        //FILTER OVER LANGUAGES IBM CAN TRANSLATE TO AND PULL OUT THE LANGUAGE-CODE OF THE LANGUAGE THE USER WANT'S TO USE\n        [{language}] = languages.filter(l => l.language_name.toLowerCase() === targetLanguage.toLowerCase());\n      } catch(e) {\n        errors[\"languageError\"] = true;\n        return \"Could not read language value\";\n      };\n\n      const translation = await fetchTranslation(language, trackId, lyrics);\n      return translation;\n    };\n\n    const translation = await handleLanguageSearchSubmit(targetLanguage, languages);\n    dispatch(retrieveTranslation(translation));\n    dispatch(updateGetTranslationErrors(errors));\n  };\n};\n\nfunction retrieveTranslation(translation) {\n  return {type: GET_TRANSLATION, translation};\n};\n\nfunction updateGetTranslationErrors(errors) {\n  return {type: UPDATE_TRANSLATION_ERRORS, errors};\n};"]},"metadata":{},"sourceType":"module"}